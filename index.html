<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Our Watchlist</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Load Inter font -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap" rel="stylesheet">
    <style>
        /* Define a romantic, deep berry and rose gold palette */
        :root {
            --color-bg-dark: #2d172e; /* Deep Berry/Plum */
            --color-bg-light: #3e283f; /* Lighter Plum */
            --color-accent-pink: #f472b6; /* Rose Pink/Fuchsia - Main Accent */
            --color-accent-gold: #fde047; /* Soft Gold/Yellow - Secondary Accent */
            --color-text: #fef3c7; /* Light creamy text */
            --color-text-faded: #a78bfa; /* Faded purple for subtitles */
        }

        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--color-bg-dark);
            color: var(--color-text);
            transition: background-color 0.3s;
        }

        .card-shadow {
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.3), 0 4px 6px -2px rgba(0, 0, 0, 0.15);
        }

        .button-style {
            transition: all 0.2s;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .button-style:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 8px rgba(0, 0, 0, 0.2);
        }
        
        /* Custom scrollbar for aesthetic appeal */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--color-bg-light);
            border-radius: 10px;
        }

        ::-webkit-scrollbar-thumb {
            background: var(--color-accent-pink);
            border-radius: 10px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #e11d48; /* Deeper red/pink on hover */
        }
    </style>
</head>
<body class="p-4 md:p-8 min-h-screen">

    <div id="app" class="max-w-4xl mx-auto">

        <!-- Header -->
        <header class="text-center mb-8">
            <h1 class="text-4xl md:text-5xl font-extrabold mb-2 tracking-tight" style="color:var(--color-accent-gold);">
                Our Watchlist üíå
            </h1>
            <p class="text-xl font-medium" style="color:var(--color-text-faded);">
                What's Next for Us?
            </p>
        </header>

        <!-- Loading & Error Messages -->
        <div id="messages" class="mb-4 space-y-3">
            <!-- Messages go here -->
        </div>

        <!-- Add Item Section (Search) -->
        <div id="search-container" class="p-6 rounded-2xl card-shadow mb-8 border-t-4" style="background-color:var(--color-bg-light); border-color:var(--color-accent-pink);">
            <h2 class="text-2xl font-bold mb-4" style="color:var(--color-accent-gold);">Find & Add Something Cute</h2>
            <div class="flex flex-col gap-3">
                
                <!-- Search Input -->
                <input type="text" id="searchInput" placeholder="Search for a Movie or Show..." class="w-full p-3 rounded-xl text-white placeholder-gray-400 focus:ring-2 focus:ring-pink-400 focus:outline-none transition duration-150" style="background-color:var(--color-bg-dark);">
                
                <!-- Search Button -->
                <button id="searchButton" class="button-style bg-pink-500 hover:bg-pink-600 text-white font-semibold py-3 px-6 rounded-xl whitespace-nowrap flex-grow">
                    Search
                </button>
            </div>
            
            <!-- Search Results Display -->
            <div id="searchResults" class="mt-4 grid grid-cols-1 md:grid-cols-2 gap-4">
                <!-- Search results will be rendered here -->
            </div>
        </div>

        <!-- Watchlist Display Section (Unwatched) -->
        <div class="p-6 rounded-2xl card-shadow mb-8 border-t-4" style="background-color:var(--color-bg-light); border-color:var(--color-accent-gold);">
            <h2 class="text-2xl font-bold mb-6" style="color:var(--color-accent-pink);">üçø Queue</h2>
            <div id="toWatchList" class="space-y-4">
                <!-- Unwatched items will be rendered here -->
                <div class="text-center text-gray-400 italic p-4" id="empty-unwatched-message" style="display: none;">
                    The queue is empty! Time to fill it up !
                </div>
            </div>
        </div>

        <!-- Watched Section -->
        <div class="p-6 rounded-2xl card-shadow border-t-4 border-gray-500" style="background-color:var(--color-bg-light);">
            <h2 class="text-2xl font-bold mb-6 text-gray-400">‚úÖ Completed </h2>
            <div id="watchedList" class="space-y-4">
                <!-- Watched items will be rendered here -->
                <div class="text-center text-gray-500 italic p-4" id="empty-watched-message" style="display: none;">
                    Time to finish something!
                </div>
            </div>
        </div>

    </div>

    <!-- JavaScript Logic (M/S Marker functionality removed) -->
    <script>
        // --- CONSTANTS & CONFIGURATION ---
        // NOTE: Keeping the URL from your previous successful setup.
        const GOOGLE_APPS_SCRIPT_URL ='https://script.google.com/macros/s/AKfycbzyr9LHf_yLV4bBiC0XNnaUszbSB8R2UOebt8ciipu0pkWBPmMIwR3W1BIk5llJAW1F/exec';
        const OMDB_API_KEY = '379bafb0';
        const OMDB_API_URL = 'https://www.omdbapi.com/';

        // --- DOM ELEMENTS ---
        const searchInput = document.getElementById('searchInput');
        const searchButton = document.getElementById('searchButton');
        const searchResults = document.getElementById('searchResults');
        const toWatchListContainer = document.getElementById('toWatchList');
        const watchedListContainer = document.getElementById('watchedList');
        const messagesContainer = document.getElementById('messages');
        const emptyUnwatchedMessage = document.getElementById('empty-unwatched-message');
        const emptyWatchedMessage = document.getElementById('empty-watched-message');

        // --- STATE & INITIALIZATION ---
        let currentWatchlist = [];
        let isProcessing = false;

        // --- UTILITY FUNCTIONS ---

        /**
         * Shows a temporary, styled message to the user (e.g., success, error).
         * @param {string} message - The message text.
         * @param {string} type - 'success' or 'error'.
         */
        function displayMessage(message, type) {
            const colors = {
                success: { bg: 'bg-green-500', border: 'border-green-700' },
                error: { bg: 'bg-red-500', border: 'border-red-700' }
            };

            const div = document.createElement('div');
            div.className = `p-4 rounded-xl text-white font-medium border-l-4 ${colors[type].bg} ${colors[type].border} card-shadow`;
            div.textContent = message;
            messagesContainer.appendChild(div);

            setTimeout(() => {
                div.remove();
            }, 5000);
        }

        /**
         * Safely makes a POST request to the Google Apps Script Web App with retry logic.
         * @param {object} payload - The object containing the 'action' and data.
         * @returns {Promise<object>} The response data from the GAS script.
         */
        async function makeGasRequest(payload) {
            if (isProcessing) return;
            isProcessing = true;

            const MAX_RETRIES = 3;
            const executeFetch = async (currentAttempt) => {
                // Exponential backoff: 1s, 2s, 4s delay before retry
                const delay = Math.pow(2, currentAttempt) * 1000;

                if (currentAttempt > 0) {
                    await new Promise(resolve => setTimeout(resolve, delay));
                }

                try {
                    const response = await fetch(GOOGLE_APPS_SCRIPT_URL, {
                        method: 'POST',
                        mode: 'cors',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify(payload)
                    });
    
                    if (!response.ok) {
                        // Throw error for bad HTTP status (4xx, 5xx)
                        const errorText = await response.text();
                        throw new Error(`HTTP error! status: ${response.status}. Response: ${errorText.substring(0, 50)}...`);
                    }
    
                    const data = await response.json();
                    
                    if (data.success === false) {
                        throw new Error(data.error || "Unknown GAS error.");
                    }
    
                    return data; // Success, return data
                    
                } catch (error) {
                    // This catches both Failed to Fetch (network) and thrown HTTP/GAS errors
                    if (currentAttempt < MAX_RETRIES - 1) {
                        // If it's not the final attempt, retry. No console logging of retry attempts.
                        return executeFetch(currentAttempt + 1); 
                    } else {
                        throw error; // Max retries reached, propagate error
                    }
                }
            };
            
            try {
                return await executeFetch(0);
            } catch (error) {
                console.error("GAS Communication Error (Max Retries Reached):", error);
                displayMessage(`Failed to communicate with the Google Sheets backend after ${MAX_RETRIES} attempts. Details: ${error.message.substring(0, 80)}`, 'error');
                return null;
            } finally {
                isProcessing = false;
            }
        }

        // --- WATCHLIST (CRUD) OPERATIONS ---

        /**
         * Fetches the full watchlist from the Google Sheet and renders it.
         */
        async function fetchWatchlist() {
            const result = await makeGasRequest({ action: 'GET_LIST' });
            if (result && result.success) {
                currentWatchlist = result.data || [];
                renderWatchlist();
            }
        }

        /**
         * Toggles the 'Watched' status of an item.
         * @param {number} id - The row ID in the Google Sheet.
         * @param {boolean} currentStatus - The current watched status.
         */
        async function toggleWatched(id, currentStatus) {
            const newStatus = !currentStatus;
            const result = await makeGasRequest({
                action: 'TOGGLE_WATCHED',
                ID: id,
                WatchedStatus: newStatus
            });
            if (result && result.success) {
                // The GAS script returns the full, updated list, so we just update the UI
                currentWatchlist = result.data;
                renderWatchlist();
                displayMessage(`Toggled to ${newStatus ? 'Unwatched' : 'Watched'}!`, 'success');
            }
        }

        /**
         * Deletes an item from the watchlist.
         * @param {number} id - The row ID in the Google Sheet.
         */
        async function deleteItem(id) {
            const result = await makeGasRequest({
                action: 'DELETE_ITEM',
                ID: id
            });
            if (result && result.success) {
                // The GAS script returns the full, updated list, so we just update the UI
                currentWatchlist = result.data;
                renderWatchlist();
                displayMessage(`Item removed from the list.`, 'success');
            }
        }

        /**
         * Adds an item from the OMDB search result to the sheet.
         * @param {object} item - The OMDB search result object.
         */
        async function addItem(item) {
            const newItem = {
                action: 'ADD_ITEM',
                Type: item.Type,
                Title: item.Title,
                Year: item.Year,
                PosterURL: item.Poster !== 'N/A' ? item.Poster : '',
                IMDB_ID: item.imdbID,
            };

            const result = await makeGasRequest(newItem);

            if (result && result.success) {
                currentWatchlist = result.data;
                renderWatchlist();
                displayMessage(`'${item.Title}' added to the list!`, 'success');
                searchResults.innerHTML = ''; // Clear search results after adding
                searchInput.value = ''; // Clear search input
            }
        }

        // --- OMDB SEARCH FUNCTIONS ---

        /**
         * Fetches and displays OMDB search results.
         */
        async function searchOmdb() {
            const query = searchInput.value.trim();
            if (!query) {
                displayMessage("Please enter a title to search.", 'error');
                return;
            }

            searchResults.innerHTML = '<p class="text-center text-gray-400 mt-4">Searching...</p>';
            
            try {
                const response = await fetch(`${OMDB_API_URL}?apikey=${OMDB_API_KEY}&s=${encodeURIComponent(query)}`);
                const data = await response.json();

                if (data.Response === "True" && data.Search) {
                    renderSearchResults(data.Search);
                } else {
                    searchResults.innerHTML = `<p class="text-center text-gray-400 mt-4 italic">No results found for "${query}".</p>`;
                }
            } catch (error) {
                console.error("OMDB Search Error:", error);
                displayMessage("Failed to connect to the movie database. Check your API key.", 'error');
                searchResults.innerHTML = '';
            }
        }

        // --- RENDERING FUNCTIONS ---

        /**
         * Renders the search results from OMDB.
         * @param {Array<object>} items - List of search results.
         */
        function renderSearchResults(items) {
            searchResults.innerHTML = '';
            items.forEach(item => {
                const card = document.createElement('div');
                card.className = "p-4 rounded-xl flex items-center gap-4 border border-gray-600 shadow-md"
                card.style.backgroundColor = 'var(--color-bg-dark)';
                
                const poster = item.Poster !== 'N/A' 
                    ? `<img src="${item.Poster}" alt="${item.Title} Poster" class="w-16 h-24 object-cover rounded-md flex-shrink-0 card-shadow" onerror="this.onerror=null; this.src='https://placehold.co/64x96/4b5563/ffffff?text=NO+IMAGE';">` 
                    : `<div class="w-16 h-24 rounded-md flex items-center justify-center text-xs text-gray-400 flex-shrink-0" style="background-color:var(--color-bg-light);">No Poster</div>`;

                const titleInfo = `
                    <div class="flex-grow min-w-0">
                        <p class="font-bold truncate text-lg text-white" title="${item.Title}">${item.Title}</p>
                        <p class="text-sm" style="color:var(--color-text-faded);">${item.Year} | ${item.Type === 'movie' ? 'üé¨ Movie' : 'üì∫ Series'}</p>
                    </div>
                `;

                const addButton = document.createElement('button');
                addButton.className = "button-style bg-pink-500 hover:bg-pink-600 text-white font-semibold py-2 px-4 rounded-xl text-sm flex-shrink-0";
                addButton.textContent = 'Add';
                addButton.onclick = () => addItem(item);

                card.innerHTML = poster + titleInfo;
                card.appendChild(addButton);
                searchResults.appendChild(card);
            });
        }

        /**
         * Renders the current watchlist, splitting it into two sections.
         */
        function renderWatchlist() {
            // Clear containers
            toWatchListContainer.innerHTML = '';
            watchedListContainer.innerHTML = '';

            // Split list based on watched status
            const toWatchList = currentWatchlist.filter(item => !(item.Watched === true || String(item.Watched).toUpperCase() === 'TRUE'));
            const watchedList = currentWatchlist.filter(item => item.Watched === true || String(item.Watched).toUpperCase() === 'TRUE');
            
            emptyUnwatchedMessage.style.display = toWatchList.length === 0 ? 'block' : 'none';
            emptyWatchedMessage.style.display = watchedList.length === 0 ? 'block' : 'none';

            // Helper function to render a single item card
            const createItemCard = (item) => {
                const isWatched = item.Watched === true || String(item.Watched).toUpperCase() === 'TRUE';
                
                // Set colors based on watched status
                const watchedStyle = isWatched 
                    ? 'bg-purple-900/30 border-purple-500/50 opacity-70' 
                    : 'border-rose-400/50 hover:bg-opacity-80';

                const typeIcon = item.Type === 'movie' ? 'üé¨' : 'üì∫';

                const card = document.createElement('div');
                card.className = `p-4 rounded-2xl flex items-center gap-4 transition duration-200 border-l-8 ${watchedStyle} card-shadow`;
                card.style.backgroundColor = 'var(--color-bg-dark)';
                
                // Poster/Placeholder
                const posterUrl = item.PosterURL;
                const posterHtml = posterUrl 
                    ? `<img src="${posterUrl}" alt="${item.Title} Poster" class="w-16 h-24 object-cover rounded-lg flex-shrink-0 card-shadow" onerror="this.onerror=null; this.src='https://placehold.co/64x96/4b5563/ffffff?text=NO+IMAGE';">` 
                    : `<div class="w-16 h-24 rounded-lg flex items-center justify-center text-xs text-gray-400 flex-shrink-0" style="background-color:var(--color-bg-light);">No Poster</div>`;

                // Title and Info
                const infoHtml = `
                    <div class="flex-grow min-w-0">
                        <div class="flex items-center gap-3">
                            <p class="font-extrabold text-xl truncate ${isWatched ? 'line-through text-gray-400' : 'text-white'}" title="${item.Title}">${item.Title}</p>
                        </div>
                        <p class="text-sm mt-1" style="color:var(--color-text-faded);">${typeIcon} ${item.Year}</p>
                    </div>
                `;
                
                // Actions
                const actionsHtml = `
                    <div class="flex flex-col sm:flex-row gap-2 flex-shrink-0 ml-auto">
                        <button onclick="toggleWatched(${item.ID}, ${isWatched})"
                            class="button-style text-sm font-semibold py-2 px-3 rounded-xl 
                            ${isWatched 
                                ? 'bg-gray-500 hover:bg-gray-600 text-white' 
                                : 'bg-pink-500 hover:bg-pink-600 text-white'}">
                            ${isWatched ? 'Unwatch' : 'Watched!'}
                        </button>
                        <button onclick="deleteItem(${item.ID})"
                            class="button-style bg-red-500 hover:bg-red-600 text-white font-semibold py-2 px-3 rounded-xl text-sm">
                            <span aria-hidden="true">üóëÔ∏è</span>
                        </button>
                    </div>
                `;

                card.innerHTML = posterHtml + infoHtml + actionsHtml;
                return card;
            };

            // Render both lists
            toWatchList.forEach(item => toWatchListContainer.appendChild(createItemCard(item)));
            watchedList.forEach(item => watchedListContainer.appendChild(createItemCard(item)));
        }

        // --- EVENT LISTENERS ---
        searchButton.addEventListener('click', searchOmdb);
        searchInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                searchOmdb();
            }
        });

        // --- INITIAL LOAD ---
        window.onload = () => {
            if (GOOGLE_APPS_SCRIPT_URL.includes('AKfycb')) {
                fetchWatchlist();
            } else {
                displayMessage("CRITICAL: Please ensure GOOGLE_APPS_SCRIPT_URL is set correctly.", 'error');
            }
        };

    </script>
</body>
</html>
